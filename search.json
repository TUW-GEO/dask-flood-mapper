[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Dask Flood Mapper",
    "section": "",
    "text": "Preface\nThis is a Jupyter notebooks on flood mapping based on the TU Wien Bayesian flood mapping algorithm implemented with Dask.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "notebooks/01_local_dask.html#cube-definitions",
    "href": "notebooks/01_local_dask.html#cube-definitions",
    "title": "1  Dask Client",
    "section": "1.1 Cube Definitions",
    "text": "1.1 Cube Definitions\nThe following generic specifications are used for presenting the data.\n\ncrs = \"EPSG:4326\" # Coordinate Reference System - World Geodetic System 1984 (WGS84) in this case \nres = 0.00018 # 20 meter in degree",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Dask Client</span>"
    ]
  },
  {
    "objectID": "notebooks/01_local_dask.html#northern-germany-flood",
    "href": "notebooks/01_local_dask.html#northern-germany-flood",
    "title": "1  Dask Client",
    "section": "1.2 Northern Germany Flood",
    "text": "1.2 Northern Germany Flood\nStorm Babet hit the Denmark and Northern coast at the 20th of October 2023 Wikipedia. Here an area around Zingst at the Baltic coast of Northern Germany is selected as the study area.\n\ntime_range = \"2022-10-11/2022-10-25\"\nminlon, maxlon = 12.3, 13.1\nminlat, maxlat = 54.3, 54.6\nbounding_box = [minlon, minlat, maxlon, maxlat]",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Dask Client</span>"
    ]
  },
  {
    "objectID": "notebooks/01_local_dask.html#eodc-stac-catalog",
    "href": "notebooks/01_local_dask.html#eodc-stac-catalog",
    "title": "1  Dask Client",
    "section": "1.3 EODC STAC Catalog",
    "text": "1.3 EODC STAC Catalog\nThe pystac_client establishes a connection to the EODC STAC Catalog. This results in a catalog object that can be used to discover collections and items hosted at EODC.\n\neodc_catalog = pystac_client.Client.open(\"https://stac.eodc.eu/api/v1\")",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Dask Client</span>"
    ]
  },
  {
    "objectID": "notebooks/01_local_dask.html#microwave-backscatter-measurements",
    "href": "notebooks/01_local_dask.html#microwave-backscatter-measurements",
    "title": "1  Dask Client",
    "section": "1.4 Microwave Backscatter Measurements",
    "text": "1.4 Microwave Backscatter Measurements\nThe basic premise of microwave-based backscattering can be seen in the sketch below, the characteristics of backscattering over land and water differ considerably. With this knowledge we can detect whenever a pixel with a predominant land like signature changes to a water like signature in the event of flooding.\n\nSchematic backscattering over land and water. Image from Geological Survey Ireland\nWe discover Sentinel-1 microwave backscatter (\\(\\sigma_0\\) [1]) at a 20 meter resolution, like so:\n\nsearch = eodc_catalog.search(\n    collections=\"SENTINEL1_SIG0_20M\",\n    bbox=bounding_box,\n    datetime=time_range,\n)\n\nitems_sig0 = search.item_collection()\n\nThe state of the orbit and relative orbit number is also saved, as the water and land likelihoods (which are calculated later on) dependent on the orbital configuration. These variables will be added as additional coordinates to the data cube. For this purpose a small helper function is defined, like so:\n\ndef extract_orbit_names(items):\n    return np.array([items[i].properties[\"sat:orbit_state\"][0].upper() + \\\n                     str(items[i].properties[\"sat:relative_orbit\"]) \\\n                     for i in range(len(items))])\n\nWe will also save the scaling factor and nodata values of STAC items to correct the loaded data accordingly. Again a helper function will be used to correctly scale and fill no data values of the cube.\n\ndef post_process_eodc_cube(dc: xr.Dataset, items, bands):\n    if not isinstance(bands, tuple):\n        bands = tuple([bands])\n    for i in bands:\n        dc[i] = post_process_eodc_cube_(dc[i], items, i)\n    return dc\n\ndef post_process_eodc_cube_(dc: xr.Dataset, items, band):\n    scale = items[0].assets[band].extra_fields.get('raster:bands')[0]['scale']\n    nodata = items[0].assets[band].extra_fields.get('raster:bands')[0]['nodata']\n    return dc.where(dc != nodata) / scale\n\nThe VV polarization of the discover items can be loaded with odc-stac and cast in the desired projection and resolution. The data is at this point only lazily loaded, meaning that we only make an instance of the outlines of the datacube with the proper shape and resolution, but without actually loading all the data. This is done by providing the chunks as defined before, which partitions the data in portions which are more easily handled by the setup used for processing the data (in this case my own pc).\n\nbands = \"VV\"\nsig0_dc = odc_stac.load(items_sig0,\n                        bands=bands,\n                        crs=crs,\n                        chunks=chunks,\n                        resolution=res,\n                        bbox=bounding_box,\n                        groupby=None,\n                        )\n\nNow we can rescale our variable, fill the no data values with np.nan values, and add the orbit names, with the previous defined functions.\n\nsig0_dc = post_process_eodc_cube(sig0_dc, items_sig0, bands).\\\n    rename_vars({ \"VV\": \"sig0\"}).\\\n    assign_coords(orbit=(\"time\", extract_orbit_names(items_sig0))).\\\n    dropna(dim=\"time\", how=\"all\").\\\n    sortby(\"time\")\n\nThen we remove duplicate time dimensions from the data cube and extract the orbit names as we will need those for obtaining the correct harmonic parameters and local incidence angles,as explained in the next section. Also, note, that we call dask.persist to materialize the object but retain it as a delayed object in the workers memory.\n\n__, indices = np.unique(sig0_dc.time, return_index=True)\nindices.sort()\norbit_sig0 = sig0_dc.orbit[indices].data\nsig0_dc = sig0_dc.groupby(\"time\").mean(skipna=True)\nsig0_dc = sig0_dc.assign_coords(orbit=(\"time\", orbit_sig0))\nsig0_dc = sig0_dc.persist()\nwait(sig0_dc)\nsig0_dc\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.Dataset&gt; Size: 237MB\nDimensions:      (time: 8, latitude: 1668, longitude: 4445)\nCoordinates:\n  * latitude     (latitude) float64 13kB 54.6 54.6 54.6 54.6 ... 54.3 54.3 54.3\n  * longitude    (longitude) float64 36kB 12.3 12.3 12.3 12.3 ... 13.1 13.1 13.1\n    spatial_ref  int32 4B 4326\n  * time         (time) datetime64[ns] 64B 2022-10-11T05:25:01 ... 2022-10-23...\n    orbit        (time) &lt;U4 128B 'D168' 'A44' 'A44' ... 'A146' 'A146' 'D168'\nData variables:\n    sig0         (time, latitude, longitude) float32 237MB dask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;xarray.DatasetDimensions:time: 8latitude: 1668longitude: 4445Coordinates: (5)latitude(latitude)float6454.6 54.6 54.6 ... 54.3 54.3 54.3units :degrees_northresolution :-0.00018crs :EPSG:4326array([54.60003, 54.59985, 54.59967, ..., 54.30033, 54.30015, 54.29997])longitude(longitude)float6412.3 12.3 12.3 ... 13.1 13.1 13.1units :degrees_eastresolution :0.00018crs :EPSG:4326array([12.30003, 12.30021, 12.30039, ..., 13.09959, 13.09977, 13.09995])spatial_ref()int324326spatial_ref :GEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],CS[ellipsoidal,2],AXIS[\"geodetic latitude (Lat)\",north,ORDER[1],ANGLEUNIT[\"degree\",0.0174532925199433]],AXIS[\"geodetic longitude (Lon)\",east,ORDER[2],ANGLEUNIT[\"degree\",0.0174532925199433]],USAGE[SCOPE[\"Horizontal component of 3D system.\"],AREA[\"World.\"],BBOX[-90,-180,90,180]],ID[\"EPSG\",4326]]crs_wkt :GEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],CS[ellipsoidal,2],AXIS[\"geodetic latitude (Lat)\",north,ORDER[1],ANGLEUNIT[\"degree\",0.0174532925199433]],AXIS[\"geodetic longitude (Lon)\",east,ORDER[2],ANGLEUNIT[\"degree\",0.0174532925199433]],USAGE[SCOPE[\"Horizontal component of 3D system.\"],AREA[\"World.\"],BBOX[-90,-180,90,180]],ID[\"EPSG\",4326]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984 ensemblegrid_mapping_name :latitude_longitudeGeoTransform :12.299940000000001205648914 0.000180000000000000011336 0 54.600120000000003983586794 0 -0.000180000000000000011336array(4326, dtype=int32)time(time)datetime64[ns]2022-10-11T05:25:01 ... 2022-10-...array(['2022-10-11T05:25:01.000000000', '2022-10-14T17:01:09.000000000',\n       '2022-10-14T17:01:34.000000000', '2022-10-16T05:33:14.000000000',\n       '2022-10-18T05:16:52.000000000', '2022-10-21T16:52:59.000000000',\n       '2022-10-21T16:53:24.000000000', '2022-10-23T05:25:01.000000000'],\n      dtype='datetime64[ns]')orbit(time)&lt;U4'D168' 'A44' ... 'A146' 'D168'array(['D168', 'A44', 'A44', 'D66', 'D95', 'A146', 'A146', 'D168'],\n      dtype='&lt;U4')Data variables: (1)sig0(time, latitude, longitude)float32dask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n226.27 MiB\n6.45 MiB\n\n\nShape\n(8, 1668, 4445)\n(1, 1300, 1300)\n\n\nDask graph\n64 chunks in 1 graph layer\n\n\nData type\nfloat32 numpy.ndarray\n\n\n\n\n                                               4445 1668 8\n\n\n\n\nIndexes: (3)latitudePandasIndexPandasIndex(Index([54.600030000000004,           54.59985,           54.59967,\n                 54.59949,           54.59931,           54.59913,\n                 54.59895,           54.59877,           54.59859,\n                 54.59841,\n       ...\n       54.301590000000004, 54.301410000000004, 54.301230000000004,\n       54.301050000000004,           54.30087,           54.30069,\n                 54.30051,           54.30033,           54.30015,\n                 54.29997],\n      dtype='float64', name='latitude', length=1668))longitudePandasIndexPandasIndex(Index([12.300030000000001, 12.300210000000002, 12.300390000000002,\n       12.300570000000002,           12.30075, 12.300930000000001,\n       12.301110000000001, 12.301290000000002, 12.301470000000002,\n       12.301650000000002,\n       ...\n                 13.09833, 13.098510000000001, 13.098690000000001,\n       13.098870000000002, 13.099050000000002, 13.099230000000002,\n                 13.09941, 13.099590000000001, 13.099770000000001,\n       13.099950000000002],\n      dtype='float64', name='longitude', length=4445))timePandasIndexPandasIndex(DatetimeIndex(['2022-10-11 05:25:01', '2022-10-14 17:01:09',\n               '2022-10-14 17:01:34', '2022-10-16 05:33:14',\n               '2022-10-18 05:16:52', '2022-10-21 16:52:59',\n               '2022-10-21 16:53:24', '2022-10-23 05:25:01'],\n              dtype='datetime64[ns]', name='time', freq=None))Attributes: (0)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Dask Client</span>"
    ]
  },
  {
    "objectID": "notebooks/01_local_dask.html#harmonic-parameters",
    "href": "notebooks/01_local_dask.html#harmonic-parameters",
    "title": "1  Dask Client",
    "section": "1.5 Harmonic Parameters",
    "text": "1.5 Harmonic Parameters\nThe so-called likelihoods of \\(P(\\sigma^0|flood)\\) and \\(P(\\sigma^0|nonflood)\\) can be calculated from past backscattering information. To be able to this we load the harmonic parameters we can model the expected variations in land back scattering based on seasonal changes in vegetation. The procedure is similar to the backscattering routine.\nWe discover items.\n\nsearch = eodc_catalog.search(\n    collections=\"SENTINEL1_HPAR\",\n    bbox=bounding_box\n)\n\nitems_hpar = search.item_collection()\n\nLoad the data as a lazy object.\n\nbands = (\"C1\", \"C2\", \"C3\", \"M0\", \"S1\", \"S2\", \"S3\", \"STD\")\nhpar_dc = odc_stac.load(items_hpar,\n                        bands=bands,\n                        crs=crs,\n                        chunks=chunks,\n                        resolution=res,\n                        bbox=bounding_box,\n                        groupby=None,\n                        )\n\nhpar_dc = post_process_eodc_cube(hpar_dc, items_hpar, bands).\\\n    rename({\"time\": \"orbit\"})\nhpar_dc[\"orbit\"] = extract_orbit_names(items_hpar)\nhpar_dc = hpar_dc.groupby(\"orbit\").mean(skipna=True)\n\nWe expand the variables along the orbits of sigma naught to be able to calculate the correct land reference backscatter signatures.\n\nhpar_dc = hpar_dc.sel(orbit = orbit_sig0)\nhpar_dc = hpar_dc.persist()\nwait(hpar_dc)\nhpar_dc\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.Dataset&gt; Size: 2GB\nDimensions:      (orbit: 8, latitude: 1668, longitude: 4445)\nCoordinates:\n  * latitude     (latitude) float64 13kB 54.6 54.6 54.6 54.6 ... 54.3 54.3 54.3\n  * longitude    (longitude) float64 36kB 12.3 12.3 12.3 12.3 ... 13.1 13.1 13.1\n    spatial_ref  int32 4B 4326\n  * orbit        (orbit) object 64B 'D168' 'A44' 'A44' ... 'A146' 'A146' 'D168'\nData variables:\n    C1           (orbit, latitude, longitude) float32 237MB dask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n    C2           (orbit, latitude, longitude) float32 237MB dask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n    C3           (orbit, latitude, longitude) float32 237MB dask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n    M0           (orbit, latitude, longitude) float32 237MB dask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n    S1           (orbit, latitude, longitude) float32 237MB dask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n    S2           (orbit, latitude, longitude) float32 237MB dask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n    S3           (orbit, latitude, longitude) float32 237MB dask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n    STD          (orbit, latitude, longitude) float32 237MB dask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;xarray.DatasetDimensions:orbit: 8latitude: 1668longitude: 4445Coordinates: (4)latitude(latitude)float6454.6 54.6 54.6 ... 54.3 54.3 54.3units :degrees_northresolution :-0.00018crs :EPSG:4326array([54.60003, 54.59985, 54.59967, ..., 54.30033, 54.30015, 54.29997])longitude(longitude)float6412.3 12.3 12.3 ... 13.1 13.1 13.1units :degrees_eastresolution :0.00018crs :EPSG:4326array([12.30003, 12.30021, 12.30039, ..., 13.09959, 13.09977, 13.09995])spatial_ref()int324326spatial_ref :GEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],CS[ellipsoidal,2],AXIS[\"geodetic latitude (Lat)\",north,ORDER[1],ANGLEUNIT[\"degree\",0.0174532925199433]],AXIS[\"geodetic longitude (Lon)\",east,ORDER[2],ANGLEUNIT[\"degree\",0.0174532925199433]],USAGE[SCOPE[\"Horizontal component of 3D system.\"],AREA[\"World.\"],BBOX[-90,-180,90,180]],ID[\"EPSG\",4326]]crs_wkt :GEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],CS[ellipsoidal,2],AXIS[\"geodetic latitude (Lat)\",north,ORDER[1],ANGLEUNIT[\"degree\",0.0174532925199433]],AXIS[\"geodetic longitude (Lon)\",east,ORDER[2],ANGLEUNIT[\"degree\",0.0174532925199433]],USAGE[SCOPE[\"Horizontal component of 3D system.\"],AREA[\"World.\"],BBOX[-90,-180,90,180]],ID[\"EPSG\",4326]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984 ensemblegrid_mapping_name :latitude_longitudeGeoTransform :12.299940000000001205648914 0.000180000000000000011336 0 54.600120000000003983586794 0 -0.000180000000000000011336array(4326, dtype=int32)orbit(orbit)object'D168' 'A44' ... 'A146' 'D168'array(['D168', 'A44', 'A44', 'D66', 'D95', 'A146', 'A146', 'D168'],\n      dtype=object)Data variables: (8)C1(orbit, latitude, longitude)float32dask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n226.27 MiB\n6.45 MiB\n\n\nShape\n(8, 1668, 4445)\n(1, 1300, 1300)\n\n\nDask graph\n64 chunks in 1 graph layer\n\n\nData type\nfloat32 numpy.ndarray\n\n\n\n\n                                               4445 1668 8\n\n\n\n\n\n\n\n\nC2\n\n\n(orbit, latitude, longitude)\n\n\nfloat32\n\n\ndask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n226.27 MiB\n6.45 MiB\n\n\nShape\n(8, 1668, 4445)\n(1, 1300, 1300)\n\n\nDask graph\n64 chunks in 1 graph layer\n\n\nData type\nfloat32 numpy.ndarray\n\n\n\n\n                                               4445 1668 8\n\n\n\n\n\n\n\n\nC3\n\n\n(orbit, latitude, longitude)\n\n\nfloat32\n\n\ndask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n226.27 MiB\n6.45 MiB\n\n\nShape\n(8, 1668, 4445)\n(1, 1300, 1300)\n\n\nDask graph\n64 chunks in 1 graph layer\n\n\nData type\nfloat32 numpy.ndarray\n\n\n\n\n                                               4445 1668 8\n\n\n\n\n\n\n\n\nM0\n\n\n(orbit, latitude, longitude)\n\n\nfloat32\n\n\ndask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n226.27 MiB\n6.45 MiB\n\n\nShape\n(8, 1668, 4445)\n(1, 1300, 1300)\n\n\nDask graph\n64 chunks in 1 graph layer\n\n\nData type\nfloat32 numpy.ndarray\n\n\n\n\n                                               4445 1668 8\n\n\n\n\n\n\n\n\nS1\n\n\n(orbit, latitude, longitude)\n\n\nfloat32\n\n\ndask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n226.27 MiB\n6.45 MiB\n\n\nShape\n(8, 1668, 4445)\n(1, 1300, 1300)\n\n\nDask graph\n64 chunks in 1 graph layer\n\n\nData type\nfloat32 numpy.ndarray\n\n\n\n\n                                               4445 1668 8\n\n\n\n\n\n\n\n\nS2\n\n\n(orbit, latitude, longitude)\n\n\nfloat32\n\n\ndask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n226.27 MiB\n6.45 MiB\n\n\nShape\n(8, 1668, 4445)\n(1, 1300, 1300)\n\n\nDask graph\n64 chunks in 1 graph layer\n\n\nData type\nfloat32 numpy.ndarray\n\n\n\n\n                                               4445 1668 8\n\n\n\n\n\n\n\n\nS3\n\n\n(orbit, latitude, longitude)\n\n\nfloat32\n\n\ndask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n226.27 MiB\n6.45 MiB\n\n\nShape\n(8, 1668, 4445)\n(1, 1300, 1300)\n\n\nDask graph\n64 chunks in 1 graph layer\n\n\nData type\nfloat32 numpy.ndarray\n\n\n\n\n                                               4445 1668 8\n\n\n\n\n\n\n\n\nSTD\n\n\n(orbit, latitude, longitude)\n\n\nfloat32\n\n\ndask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n226.27 MiB\n6.45 MiB\n\n\nShape\n(8, 1668, 4445)\n(1, 1300, 1300)\n\n\nDask graph\n64 chunks in 1 graph layer\n\n\nData type\nfloat32 numpy.ndarray\n\n\n\n\n                                               4445 1668 8\n\n\n\n\n\nIndexes: (3)latitudePandasIndexPandasIndex(Index([54.600030000000004,           54.59985,           54.59967,\n                 54.59949,           54.59931,           54.59913,\n                 54.59895,           54.59877,           54.59859,\n                 54.59841,\n       ...\n       54.301590000000004, 54.301410000000004, 54.301230000000004,\n       54.301050000000004,           54.30087,           54.30069,\n                 54.30051,           54.30033,           54.30015,\n                 54.29997],\n      dtype='float64', name='latitude', length=1668))longitudePandasIndexPandasIndex(Index([12.300030000000001, 12.300210000000002, 12.300390000000002,\n       12.300570000000002,           12.30075, 12.300930000000001,\n       12.301110000000001, 12.301290000000002, 12.301470000000002,\n       12.301650000000002,\n       ...\n                 13.09833, 13.098510000000001, 13.098690000000001,\n       13.098870000000002, 13.099050000000002, 13.099230000000002,\n                 13.09941, 13.099590000000001, 13.099770000000001,\n       13.099950000000002],\n      dtype='float64', name='longitude', length=4445))orbitPandasIndexPandasIndex(Index(['D168', 'A44', 'A44', 'D66', 'D95', 'A146', 'A146', 'D168'], dtype='object', name='orbit'))Attributes: (0)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Dask Client</span>"
    ]
  },
  {
    "objectID": "notebooks/01_local_dask.html#local-incidence-angles",
    "href": "notebooks/01_local_dask.html#local-incidence-angles",
    "title": "1  Dask Client",
    "section": "1.6 Local Incidence Angles",
    "text": "1.6 Local Incidence Angles\nLocal incidence angles of measured microwave backscattering is as well important for calculating reference backscatter values, but now for water bodies. The procedure is much the same as for the harmonic parameters.\n\nsearch = eodc_catalog.search(\n    collections=\"SENTINEL1_MPLIA\",\n    bbox=bounding_box\n)\n\nitems_plia = search.item_collection()\n\nLoad the lazy object and preprocess.\n\nbands = \"MPLIA\"\nplia_dc = odc_stac.load(items_plia,\n                        bands=bands,\n                        crs=crs,\n                        chunks=chunks,\n                        resolution=res,\n                        bbox=bounding_box,\n                        groupby=None,\n                        )\n\nplia_dc = post_process_eodc_cube(plia_dc, items_plia, bands).\\\n    rename({\"time\": \"orbit\"})\nplia_dc[\"orbit\"] = extract_orbit_names(items_plia)\nplia_dc = plia_dc.groupby(\"orbit\").mean(skipna=True)\n\nWe expand the variables along the orbits of sigma naught to be able to calculate the correct land reference backscatter signatures.\n\nplia_dc = plia_dc.sel(orbit = orbit_sig0)\nplia_dc = plia_dc.persist()\nwait(plia_dc)\nplia_dc\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.Dataset&gt; Size: 237MB\nDimensions:      (orbit: 8, latitude: 1668, longitude: 4445)\nCoordinates:\n  * latitude     (latitude) float64 13kB 54.6 54.6 54.6 54.6 ... 54.3 54.3 54.3\n  * longitude    (longitude) float64 36kB 12.3 12.3 12.3 12.3 ... 13.1 13.1 13.1\n    spatial_ref  int32 4B 4326\n  * orbit        (orbit) object 64B 'D168' 'A44' 'A44' ... 'A146' 'A146' 'D168'\nData variables:\n    MPLIA        (orbit, latitude, longitude) float32 237MB dask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;xarray.DatasetDimensions:orbit: 8latitude: 1668longitude: 4445Coordinates: (4)latitude(latitude)float6454.6 54.6 54.6 ... 54.3 54.3 54.3units :degrees_northresolution :-0.00018crs :EPSG:4326array([54.60003, 54.59985, 54.59967, ..., 54.30033, 54.30015, 54.29997])longitude(longitude)float6412.3 12.3 12.3 ... 13.1 13.1 13.1units :degrees_eastresolution :0.00018crs :EPSG:4326array([12.30003, 12.30021, 12.30039, ..., 13.09959, 13.09977, 13.09995])spatial_ref()int324326spatial_ref :GEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],CS[ellipsoidal,2],AXIS[\"geodetic latitude (Lat)\",north,ORDER[1],ANGLEUNIT[\"degree\",0.0174532925199433]],AXIS[\"geodetic longitude (Lon)\",east,ORDER[2],ANGLEUNIT[\"degree\",0.0174532925199433]],USAGE[SCOPE[\"Horizontal component of 3D system.\"],AREA[\"World.\"],BBOX[-90,-180,90,180]],ID[\"EPSG\",4326]]crs_wkt :GEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],CS[ellipsoidal,2],AXIS[\"geodetic latitude (Lat)\",north,ORDER[1],ANGLEUNIT[\"degree\",0.0174532925199433]],AXIS[\"geodetic longitude (Lon)\",east,ORDER[2],ANGLEUNIT[\"degree\",0.0174532925199433]],USAGE[SCOPE[\"Horizontal component of 3D system.\"],AREA[\"World.\"],BBOX[-90,-180,90,180]],ID[\"EPSG\",4326]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984 ensemblegrid_mapping_name :latitude_longitudeGeoTransform :12.299940000000001205648914 0.000180000000000000011336 0 54.600120000000003983586794 0 -0.000180000000000000011336array(4326, dtype=int32)orbit(orbit)object'D168' 'A44' ... 'A146' 'D168'array(['D168', 'A44', 'A44', 'D66', 'D95', 'A146', 'A146', 'D168'],\n      dtype=object)Data variables: (1)MPLIA(orbit, latitude, longitude)float32dask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n226.27 MiB\n6.45 MiB\n\n\nShape\n(8, 1668, 4445)\n(1, 1300, 1300)\n\n\nDask graph\n64 chunks in 1 graph layer\n\n\nData type\nfloat32 numpy.ndarray\n\n\n\n\n                                               4445 1668 8\n\n\n\n\nIndexes: (3)latitudePandasIndexPandasIndex(Index([54.600030000000004,           54.59985,           54.59967,\n                 54.59949,           54.59931,           54.59913,\n                 54.59895,           54.59877,           54.59859,\n                 54.59841,\n       ...\n       54.301590000000004, 54.301410000000004, 54.301230000000004,\n       54.301050000000004,           54.30087,           54.30069,\n                 54.30051,           54.30033,           54.30015,\n                 54.29997],\n      dtype='float64', name='latitude', length=1668))longitudePandasIndexPandasIndex(Index([12.300030000000001, 12.300210000000002, 12.300390000000002,\n       12.300570000000002,           12.30075, 12.300930000000001,\n       12.301110000000001, 12.301290000000002, 12.301470000000002,\n       12.301650000000002,\n       ...\n                 13.09833, 13.098510000000001, 13.098690000000001,\n       13.098870000000002, 13.099050000000002, 13.099230000000002,\n                 13.09941, 13.099590000000001, 13.099770000000001,\n       13.099950000000002],\n      dtype='float64', name='longitude', length=4445))orbitPandasIndexPandasIndex(Index(['D168', 'A44', 'A44', 'D66', 'D95', 'A146', 'A146', 'D168'], dtype='object', name='orbit'))Attributes: (0)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Dask Client</span>"
    ]
  },
  {
    "objectID": "notebooks/01_local_dask.html#esa-world-cover-from-terrascope",
    "href": "notebooks/01_local_dask.html#esa-world-cover-from-terrascope",
    "title": "1  Dask Client",
    "section": "1.7 ESA World Cover from Terrascope",
    "text": "1.7 ESA World Cover from Terrascope\nFor flood mapping we are only interested in microwave backscattering over what used to be land, as such, we need a way to mask water bodies. For this we use the ESA World Cover data from the following STAC catalog.\n\nimport os\nos.environ['AWS_NO_SIGN_REQUEST'] = 'YES'\nwcover_catalog = pystac_client.Client.open('https://services.terrascope.be/stac/')\n\nSimilarly, we discover the required items.\n\nsearch = wcover_catalog.search(\n    collections= \"urn:eop:VITO:ESA_WorldCover_10m_2021_AWS_V2\",\n    bbox=bounding_box\n)\n\nitems_wcover = search.item_collection()\n\nLoad the data lazily.\n\nwcover_dc = odc_stac.load(items_wcover,\n                        crs=crs,\n                        chunks=chunks,\n                        resolution=res,\n                        bbox=bounding_box,\n                       ).\\\n    squeeze(\"time\").\\\n    drop_vars(\"time\").\\\n    rename_vars({\"ESA_WORLDCOVER_10M_MAP\": \"wcover\"})\nwcover_dc = wcover_dc.persist()\nwait(wcover_dc)\nwcover_dc\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.Dataset&gt; Size: 30MB\nDimensions:      (latitude: 1668, longitude: 4445)\nCoordinates:\n  * latitude     (latitude) float64 13kB 54.6 54.6 54.6 54.6 ... 54.3 54.3 54.3\n  * longitude    (longitude) float64 36kB 12.3 12.3 12.3 12.3 ... 13.1 13.1 13.1\n    spatial_ref  int32 4B 4326\nData variables:\n    wcover       (latitude, longitude) float32 30MB dask.array&lt;chunksize=(1300, 1300), meta=np.ndarray&gt;xarray.DatasetDimensions:latitude: 1668longitude: 4445Coordinates: (3)latitude(latitude)float6454.6 54.6 54.6 ... 54.3 54.3 54.3units :degrees_northresolution :-0.00018crs :EPSG:4326array([54.60003, 54.59985, 54.59967, ..., 54.30033, 54.30015, 54.29997])longitude(longitude)float6412.3 12.3 12.3 ... 13.1 13.1 13.1units :degrees_eastresolution :0.00018crs :EPSG:4326array([12.30003, 12.30021, 12.30039, ..., 13.09959, 13.09977, 13.09995])spatial_ref()int324326spatial_ref :GEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],CS[ellipsoidal,2],AXIS[\"geodetic latitude (Lat)\",north,ORDER[1],ANGLEUNIT[\"degree\",0.0174532925199433]],AXIS[\"geodetic longitude (Lon)\",east,ORDER[2],ANGLEUNIT[\"degree\",0.0174532925199433]],USAGE[SCOPE[\"Horizontal component of 3D system.\"],AREA[\"World.\"],BBOX[-90,-180,90,180]],ID[\"EPSG\",4326]]crs_wkt :GEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],CS[ellipsoidal,2],AXIS[\"geodetic latitude (Lat)\",north,ORDER[1],ANGLEUNIT[\"degree\",0.0174532925199433]],AXIS[\"geodetic longitude (Lon)\",east,ORDER[2],ANGLEUNIT[\"degree\",0.0174532925199433]],USAGE[SCOPE[\"Horizontal component of 3D system.\"],AREA[\"World.\"],BBOX[-90,-180,90,180]],ID[\"EPSG\",4326]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984 ensemblegrid_mapping_name :latitude_longitudeGeoTransform :12.299940000000001205648914 0.000180000000000000011336 0 54.600120000000003983586794 0 -0.000180000000000000011336array(4326, dtype=int32)Data variables: (1)wcover(latitude, longitude)float32dask.array&lt;chunksize=(1300, 1300), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n28.28 MiB\n6.45 MiB\n\n\nShape\n(1668, 4445)\n(1300, 1300)\n\n\nDask graph\n8 chunks in 1 graph layer\n\n\nData type\nfloat32 numpy.ndarray\n\n\n\n\n             4445 1668\n\n\n\n\nIndexes: (2)latitudePandasIndexPandasIndex(Index([54.600030000000004,           54.59985,           54.59967,\n                 54.59949,           54.59931,           54.59913,\n                 54.59895,           54.59877,           54.59859,\n                 54.59841,\n       ...\n       54.301590000000004, 54.301410000000004, 54.301230000000004,\n       54.301050000000004,           54.30087,           54.30069,\n                 54.30051,           54.30033,           54.30015,\n                 54.29997],\n      dtype='float64', name='latitude', length=1668))longitudePandasIndexPandasIndex(Index([12.300030000000001, 12.300210000000002, 12.300390000000002,\n       12.300570000000002,           12.30075, 12.300930000000001,\n       12.301110000000001, 12.301290000000002, 12.301470000000002,\n       12.301650000000002,\n       ...\n                 13.09833, 13.098510000000001, 13.098690000000001,\n       13.098870000000002, 13.099050000000002, 13.099230000000002,\n                 13.09941, 13.099590000000001, 13.099770000000001,\n       13.099950000000002],\n      dtype='float64', name='longitude', length=4445))Attributes: (0)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Dask Client</span>"
    ]
  },
  {
    "objectID": "notebooks/01_local_dask.html#fuse-cube",
    "href": "notebooks/01_local_dask.html#fuse-cube",
    "title": "1  Dask Client",
    "section": "1.8 Fuse cube",
    "text": "1.8 Fuse cube\nHere we fuse the four data cubes together and filter for the values that have a HAND value of above zero. We can now drop the obit coordinates as well as time slices which contain no land backscattering data.\n\nflood_dc = xr.merge([sig0_dc, plia_dc, hpar_dc, wcover_dc])\nflood_dc = flood_dc.where(flood_dc.wcover != 80)\nflood_dc = flood_dc.\\\n    reset_index(\"orbit\", drop=True).\\\n    rename({\"orbit\": \"time\"}).\\\n    dropna(dim=\"time\", how=\"all\", subset=[\"sig0\"])\nflood_dc = flood_dc.persist()\nwait(flood_dc)\nflood_dc\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.Dataset&gt; Size: 2GB\nDimensions:      (time: 6, latitude: 1668, longitude: 4445)\nCoordinates:\n  * latitude     (latitude) float64 13kB 54.6 54.6 54.6 54.6 ... 54.3 54.3 54.3\n  * longitude    (longitude) float64 36kB 12.3 12.3 12.3 12.3 ... 13.1 13.1 13.1\n    spatial_ref  int32 4B 4326\n  * time         (time) datetime64[ns] 48B 2022-10-11T05:25:01 ... 2022-10-23...\nData variables:\n    sig0         (time, latitude, longitude) float32 178MB dask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n    MPLIA        (time, latitude, longitude) float32 178MB dask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n    C1           (time, latitude, longitude) float32 178MB dask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n    C2           (time, latitude, longitude) float32 178MB dask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n    C3           (time, latitude, longitude) float32 178MB dask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n    M0           (time, latitude, longitude) float32 178MB dask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n    S1           (time, latitude, longitude) float32 178MB dask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n    S2           (time, latitude, longitude) float32 178MB dask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n    S3           (time, latitude, longitude) float32 178MB dask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n    STD          (time, latitude, longitude) float32 178MB dask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n    wcover       (latitude, longitude) float32 30MB dask.array&lt;chunksize=(1300, 1300), meta=np.ndarray&gt;xarray.DatasetDimensions:time: 6latitude: 1668longitude: 4445Coordinates: (4)latitude(latitude)float6454.6 54.6 54.6 ... 54.3 54.3 54.3units :degrees_northresolution :-0.00018crs :EPSG:4326array([54.60003, 54.59985, 54.59967, ..., 54.30033, 54.30015, 54.29997])longitude(longitude)float6412.3 12.3 12.3 ... 13.1 13.1 13.1units :degrees_eastresolution :0.00018crs :EPSG:4326array([12.30003, 12.30021, 12.30039, ..., 13.09959, 13.09977, 13.09995])spatial_ref()int324326spatial_ref :GEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],CS[ellipsoidal,2],AXIS[\"geodetic latitude (Lat)\",north,ORDER[1],ANGLEUNIT[\"degree\",0.0174532925199433]],AXIS[\"geodetic longitude (Lon)\",east,ORDER[2],ANGLEUNIT[\"degree\",0.0174532925199433]],USAGE[SCOPE[\"Horizontal component of 3D system.\"],AREA[\"World.\"],BBOX[-90,-180,90,180]],ID[\"EPSG\",4326]]crs_wkt :GEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],CS[ellipsoidal,2],AXIS[\"geodetic latitude (Lat)\",north,ORDER[1],ANGLEUNIT[\"degree\",0.0174532925199433]],AXIS[\"geodetic longitude (Lon)\",east,ORDER[2],ANGLEUNIT[\"degree\",0.0174532925199433]],USAGE[SCOPE[\"Horizontal component of 3D system.\"],AREA[\"World.\"],BBOX[-90,-180,90,180]],ID[\"EPSG\",4326]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984 ensemblegrid_mapping_name :latitude_longitudeGeoTransform :12.299940000000001205648914 0.000180000000000000011336 0 54.600120000000003983586794 0 -0.000180000000000000011336array(4326, dtype=int32)time(time)datetime64[ns]2022-10-11T05:25:01 ... 2022-10-...array(['2022-10-11T05:25:01.000000000', '2022-10-14T17:01:09.000000000',\n       '2022-10-16T05:33:14.000000000', '2022-10-18T05:16:52.000000000',\n       '2022-10-21T16:52:59.000000000', '2022-10-23T05:25:01.000000000'],\n      dtype='datetime64[ns]')Data variables: (11)sig0(time, latitude, longitude)float32dask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n169.70 MiB\n6.45 MiB\n\n\nShape\n(6, 1668, 4445)\n(1, 1300, 1300)\n\n\nDask graph\n48 chunks in 1 graph layer\n\n\nData type\nfloat32 numpy.ndarray\n\n\n\n\n                                           4445 1668 6\n\n\n\n\n\n\n\n\nMPLIA\n\n\n(time, latitude, longitude)\n\n\nfloat32\n\n\ndask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n169.70 MiB\n6.45 MiB\n\n\nShape\n(6, 1668, 4445)\n(1, 1300, 1300)\n\n\nDask graph\n48 chunks in 1 graph layer\n\n\nData type\nfloat32 numpy.ndarray\n\n\n\n\n                                           4445 1668 6\n\n\n\n\n\n\n\n\nC1\n\n\n(time, latitude, longitude)\n\n\nfloat32\n\n\ndask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n169.70 MiB\n6.45 MiB\n\n\nShape\n(6, 1668, 4445)\n(1, 1300, 1300)\n\n\nDask graph\n48 chunks in 1 graph layer\n\n\nData type\nfloat32 numpy.ndarray\n\n\n\n\n                                           4445 1668 6\n\n\n\n\n\n\n\n\nC2\n\n\n(time, latitude, longitude)\n\n\nfloat32\n\n\ndask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n169.70 MiB\n6.45 MiB\n\n\nShape\n(6, 1668, 4445)\n(1, 1300, 1300)\n\n\nDask graph\n48 chunks in 1 graph layer\n\n\nData type\nfloat32 numpy.ndarray\n\n\n\n\n                                           4445 1668 6\n\n\n\n\n\n\n\n\nC3\n\n\n(time, latitude, longitude)\n\n\nfloat32\n\n\ndask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n169.70 MiB\n6.45 MiB\n\n\nShape\n(6, 1668, 4445)\n(1, 1300, 1300)\n\n\nDask graph\n48 chunks in 1 graph layer\n\n\nData type\nfloat32 numpy.ndarray\n\n\n\n\n                                           4445 1668 6\n\n\n\n\n\n\n\n\nM0\n\n\n(time, latitude, longitude)\n\n\nfloat32\n\n\ndask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n169.70 MiB\n6.45 MiB\n\n\nShape\n(6, 1668, 4445)\n(1, 1300, 1300)\n\n\nDask graph\n48 chunks in 1 graph layer\n\n\nData type\nfloat32 numpy.ndarray\n\n\n\n\n                                           4445 1668 6\n\n\n\n\n\n\n\n\nS1\n\n\n(time, latitude, longitude)\n\n\nfloat32\n\n\ndask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n169.70 MiB\n6.45 MiB\n\n\nShape\n(6, 1668, 4445)\n(1, 1300, 1300)\n\n\nDask graph\n48 chunks in 1 graph layer\n\n\nData type\nfloat32 numpy.ndarray\n\n\n\n\n                                           4445 1668 6\n\n\n\n\n\n\n\n\nS2\n\n\n(time, latitude, longitude)\n\n\nfloat32\n\n\ndask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n169.70 MiB\n6.45 MiB\n\n\nShape\n(6, 1668, 4445)\n(1, 1300, 1300)\n\n\nDask graph\n48 chunks in 1 graph layer\n\n\nData type\nfloat32 numpy.ndarray\n\n\n\n\n                                           4445 1668 6\n\n\n\n\n\n\n\n\nS3\n\n\n(time, latitude, longitude)\n\n\nfloat32\n\n\ndask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n169.70 MiB\n6.45 MiB\n\n\nShape\n(6, 1668, 4445)\n(1, 1300, 1300)\n\n\nDask graph\n48 chunks in 1 graph layer\n\n\nData type\nfloat32 numpy.ndarray\n\n\n\n\n                                           4445 1668 6\n\n\n\n\n\n\n\n\nSTD\n\n\n(time, latitude, longitude)\n\n\nfloat32\n\n\ndask.array&lt;chunksize=(1, 1300, 1300), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n169.70 MiB\n6.45 MiB\n\n\nShape\n(6, 1668, 4445)\n(1, 1300, 1300)\n\n\nDask graph\n48 chunks in 1 graph layer\n\n\nData type\nfloat32 numpy.ndarray\n\n\n\n\n                                           4445 1668 6\n\n\n\n\n\n\n\n\nwcover\n\n\n(latitude, longitude)\n\n\nfloat32\n\n\ndask.array&lt;chunksize=(1300, 1300), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n28.28 MiB\n6.45 MiB\n\n\nShape\n(1668, 4445)\n(1300, 1300)\n\n\nDask graph\n8 chunks in 1 graph layer\n\n\nData type\nfloat32 numpy.ndarray\n\n\n\n\n             4445 1668\n\n\n\n\n\nIndexes: (3)latitudePandasIndexPandasIndex(Index([54.600030000000004,           54.59985,           54.59967,\n                 54.59949,           54.59931,           54.59913,\n                 54.59895,           54.59877,           54.59859,\n                 54.59841,\n       ...\n       54.301590000000004, 54.301410000000004, 54.301230000000004,\n       54.301050000000004,           54.30087,           54.30069,\n                 54.30051,           54.30033,           54.30015,\n                 54.29997],\n      dtype='float64', name='latitude', length=1668))longitudePandasIndexPandasIndex(Index([12.300030000000001, 12.300210000000002, 12.300390000000002,\n       12.300570000000002,           12.30075, 12.300930000000001,\n       12.301110000000001, 12.301290000000002, 12.301470000000002,\n       12.301650000000002,\n       ...\n                 13.09833, 13.098510000000001, 13.098690000000001,\n       13.098870000000002, 13.099050000000002, 13.099230000000002,\n                 13.09941, 13.099590000000001, 13.099770000000001,\n       13.099950000000002],\n      dtype='float64', name='longitude', length=4445))timePandasIndexPandasIndex(DatetimeIndex(['2022-10-11 05:25:01', '2022-10-14 17:01:09',\n               '2022-10-16 05:33:14', '2022-10-18 05:16:52',\n               '2022-10-21 16:52:59', '2022-10-23 05:25:01'],\n              dtype='datetime64[ns]', name='time', freq=None))Attributes: (0)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Dask Client</span>"
    ]
  },
  {
    "objectID": "notebooks/01_local_dask.html#likelihoods",
    "href": "notebooks/01_local_dask.html#likelihoods",
    "title": "1  Dask Client",
    "section": "1.9 Likelihoods",
    "text": "1.9 Likelihoods\nNow we are ready to calculate the likelihoods of micorwave backscattering given flooding (or non flooding).\n\n1.9.1 Water\nWe start with water which is the simplest calculation, where the hard coded values are coefficients of a regression model fitted to global water backscattering values.\n\ndef calc_water_likelihood(dc):\n    return  dc.MPLIA * -0.394181 + -4.142015\n\n\nflood_dc[\"wbsc\"] = calc_water_likelihood(flood_dc)\n\n\n\n1.9.2 Land\nFor land backscattering we construct the harmonic model from the parameters as contained in the fused data cube. By doing so, we obtain a reference land backscattering value to which to compare our actual observed sigma naught values.\n\ndef harmonic_expected_backscatter(dc):\n    w = np.pi * 2 / 365\n    \n    t = dc.time.dt.dayofyear\n    wt = w * t\n    \n    M0 = dc.M0\n    S1 = dc.S1\n    S2 = dc.S2\n    S3 = dc.S3\n    C1 = dc.C1\n    C2 = dc.C2\n    C3 = dc.C3\n    hm_c1 = (M0 + S1 * np.sin(wt)) + (C1 * np.cos(wt))\n    hm_c2 = ((hm_c1 + S2 * np.sin(2 * wt)) + C2 * np.cos(2 * wt))\n    hm_c3 = ((hm_c2 + S3 * np.sin(3 * wt)) + C3 * np.cos(3 * wt))\n    return hm_c3\n\n\nflood_dc[\"hbsc\"] = harmonic_expected_backscatter(flood_dc)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Dask Client</span>"
    ]
  },
  {
    "objectID": "notebooks/01_local_dask.html#flood-mapping",
    "href": "notebooks/01_local_dask.html#flood-mapping",
    "title": "1  Dask Client",
    "section": "1.10 Flood mapping",
    "text": "1.10 Flood mapping\nHaving calculated the likelihoods, we can now move on to calculate the probability of (non-)flooding given a pixel’s \\(\\sigma^0\\). These so-called posteriors need one more piece of information, as can be seen in the equation above. We need the probability that a pixel is flooded \\(P(F)\\) or not flooded \\(P(NF)\\). Of course, these are the figures we’ve been trying to find this whole time. We don’t actually have them yet, so what can we do? In Bayesian statistics, we can just start with our best guess. These guesses are called our “priors”, because they are the beliefs we hold prior to looking at the data. This subjective prior belief is the foundation Bayesian statistics, and we use the likelihoods we just calculated to update our belief in this particular hypothesis. This updated belief is called the “posterior”.\nLet’s say that our best estimate for the chance of flooding versus non-flooding of a pixel is 50-50: a coin flip. We now can also calculate the probability of backscattering \\(P(\\sigma^0)\\), as the weighted average of the water and land likelihoods, ensuring that our posteriors range between 0 to 1.\nThe following code block shows how we calculate the priors which allow use to predict whether it is likely if a land pixel became flooded.\n\ndef bayesian_flood_decision(dc):\n    \n    nf_std = 2.754041\n    sig0 = dc.sig0\n    std = dc.STD\n    wbsc = dc.wbsc\n    hbsc = dc.hbsc\n\n    f_prob = (1.0 / (std * np.sqrt(2 * np.pi))) * np.exp(-0.5 * \\\n        (((sig0 - wbsc) / nf_std) ** 2))\n    nf_prob = (1.0 / (nf_std * np.sqrt(2 * np.pi))) * np.exp(-0.5 * \\\n        (((sig0 - hbsc) / nf_std) ** 2))\n    \n    evidence = (nf_prob * 0.5) + (f_prob * 0.5)\n    nf_post_prob = (nf_prob * 0.5) / evidence\n    f_post_prob = (f_prob * 0.5) / evidence\n    decision = xr.where(np.isnan(f_post_prob) | np.isnan(nf_post_prob), np.nan, np.greater(f_post_prob, nf_post_prob))\n    return nf_post_prob, f_post_prob, decision\n\n\nflood_dc[[\"nf_post_prob\", \"f_post_prob\", \"decision\"]] = bayesian_flood_decision(flood_dc)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Dask Client</span>"
    ]
  },
  {
    "objectID": "notebooks/01_local_dask.html#postprocessing",
    "href": "notebooks/01_local_dask.html#postprocessing",
    "title": "1  Dask Client",
    "section": "1.11 Postprocessing",
    "text": "1.11 Postprocessing\nWe continue by improving our flood map by filtering out observations that we expect to have low sensitivity to flooding based on a predefined set of criteria.\nThese criteria include: * Masking of Exceeding Incidence Angles * Identification of Conflicting Distributions * Removal of Measurement Outliers * Denial of High Uncertainty on Decision\n\ndef post_processing(dc):\n    dc = dc * np.logical_and(dc.MPLIA &gt;= 27, dc.MPLIA &lt;= 48)\n    dc = dc * (dc.hbsc &gt; (dc.wbsc + 0.5 * 2.754041))\n    land_bsc_lower = dc.hbsc - 3 * dc.STD\n    land_bsc_upper = dc.hbsc + 3 * dc.STD\n    water_bsc_upper = dc.wbsc + 3 * 2.754041\n    mask_land_outliers = np.logical_and(dc.sig0 &gt; land_bsc_lower, dc.sig0 &lt; land_bsc_upper)\n    mask_water_outliers = dc.sig0 &lt; water_bsc_upper\n    dc = dc * (mask_land_outliers | mask_water_outliers)\n    return  (dc * (dc.f_post_prob &gt; 0.8)).decision\n\n\nflood_output = post_processing(flood_dc)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Dask Client</span>"
    ]
  },
  {
    "objectID": "notebooks/01_local_dask.html#removal-of-speckles",
    "href": "notebooks/01_local_dask.html#removal-of-speckles",
    "title": "1  Dask Client",
    "section": "1.12 Removal of Speckles",
    "text": "1.12 Removal of Speckles\nThe following step is designed to further improve the clarity of the floodmaps. These filters do not directly relate to prior knowledge on backscattering, but consists of contextual evidence that supports, or oppose, a flood classification. This mainly targets so-called speckles. These speckles are areas of one or a few pixels, and which are likely the result of the diversity of scattering surfaces at a sub-pixel level. In this approach it is argued that small, solitary flood surfaces are unlikely. Hence speckles are removed by applying a smoothing filter which consists of a rolling window median along the x and y-axis simultaneously.\n\nflood_output = flood_output.rolling({\"longitude\": 5, \"latitude\": 5}, center=True).median(skipna=True).persist()\nwait(flood_output)\nflood_output\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray 'decision' (time: 6, latitude: 1668, longitude: 4445)&gt; Size: 356MB\ndask.array&lt;where, shape=(6, 1668, 4445), dtype=float64, chunksize=(1, 1302, 1302), chunktype=numpy.ndarray&gt;\nCoordinates:\n  * latitude     (latitude) float64 13kB 54.6 54.6 54.6 54.6 ... 54.3 54.3 54.3\n  * longitude    (longitude) float64 36kB 12.3 12.3 12.3 12.3 ... 13.1 13.1 13.1\n    spatial_ref  int32 4B 4326\n  * time         (time) datetime64[ns] 48B 2022-10-11T05:25:01 ... 2022-10-23...xarray.DataArray'decision'time: 6latitude: 1668longitude: 4445dask.array&lt;chunksize=(1, 1302, 1302), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n339.40 MiB\n12.93 MiB\n\n\nShape\n(6, 1668, 4445)\n(1, 1302, 1302)\n\n\nDask graph\n90 chunks in 1 graph layer\n\n\nData type\nfloat64 numpy.ndarray\n\n\n\n\n                                               4445 1668 6\n\n\n\n\nCoordinates: (4)latitude(latitude)float6454.6 54.6 54.6 ... 54.3 54.3 54.3units :degrees_northresolution :-0.00018crs :EPSG:4326array([54.60003, 54.59985, 54.59967, ..., 54.30033, 54.30015, 54.29997])longitude(longitude)float6412.3 12.3 12.3 ... 13.1 13.1 13.1units :degrees_eastresolution :0.00018crs :EPSG:4326array([12.30003, 12.30021, 12.30039, ..., 13.09959, 13.09977, 13.09995])spatial_ref()int324326spatial_ref :GEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],CS[ellipsoidal,2],AXIS[\"geodetic latitude (Lat)\",north,ORDER[1],ANGLEUNIT[\"degree\",0.0174532925199433]],AXIS[\"geodetic longitude (Lon)\",east,ORDER[2],ANGLEUNIT[\"degree\",0.0174532925199433]],USAGE[SCOPE[\"Horizontal component of 3D system.\"],AREA[\"World.\"],BBOX[-90,-180,90,180]],ID[\"EPSG\",4326]]crs_wkt :GEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],CS[ellipsoidal,2],AXIS[\"geodetic latitude (Lat)\",north,ORDER[1],ANGLEUNIT[\"degree\",0.0174532925199433]],AXIS[\"geodetic longitude (Lon)\",east,ORDER[2],ANGLEUNIT[\"degree\",0.0174532925199433]],USAGE[SCOPE[\"Horizontal component of 3D system.\"],AREA[\"World.\"],BBOX[-90,-180,90,180]],ID[\"EPSG\",4326]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984 ensemblegrid_mapping_name :latitude_longitudeGeoTransform :12.299940000000001205648914 0.000180000000000000011336 0 54.600120000000003983586794 0 -0.000180000000000000011336array(4326, dtype=int32)time(time)datetime64[ns]2022-10-11T05:25:01 ... 2022-10-...array(['2022-10-11T05:25:01.000000000', '2022-10-14T17:01:09.000000000',\n       '2022-10-16T05:33:14.000000000', '2022-10-18T05:16:52.000000000',\n       '2022-10-21T16:52:59.000000000', '2022-10-23T05:25:01.000000000'],\n      dtype='datetime64[ns]')Indexes: (3)latitudePandasIndexPandasIndex(Index([54.600030000000004,           54.59985,           54.59967,\n                 54.59949,           54.59931,           54.59913,\n                 54.59895,           54.59877,           54.59859,\n                 54.59841,\n       ...\n       54.301590000000004, 54.301410000000004, 54.301230000000004,\n       54.301050000000004,           54.30087,           54.30069,\n                 54.30051,           54.30033,           54.30015,\n                 54.29997],\n      dtype='float64', name='latitude', length=1668))longitudePandasIndexPandasIndex(Index([12.300030000000001, 12.300210000000002, 12.300390000000002,\n       12.300570000000002,           12.30075, 12.300930000000001,\n       12.301110000000001, 12.301290000000002, 12.301470000000002,\n       12.301650000000002,\n       ...\n                 13.09833, 13.098510000000001, 13.098690000000001,\n       13.098870000000002, 13.099050000000002, 13.099230000000002,\n                 13.09941, 13.099590000000001, 13.099770000000001,\n       13.099950000000002],\n      dtype='float64', name='longitude', length=4445))timePandasIndexPandasIndex(DatetimeIndex(['2022-10-11 05:25:01', '2022-10-14 17:01:09',\n               '2022-10-16 05:33:14', '2022-10-18 05:16:52',\n               '2022-10-21 16:52:59', '2022-10-23 05:25:01'],\n              dtype='datetime64[ns]', name='time', freq=None))Attributes: (0)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Dask Client</span>"
    ]
  },
  {
    "objectID": "notebooks/01_local_dask.html#results",
    "href": "notebooks/01_local_dask.html#results",
    "title": "1  Dask Client",
    "section": "1.13 Results",
    "text": "1.13 Results\nWe are now ready to visualize our results.\n\nflood_output.plot(col=\"time\", col_wrap=3)\n\n\n\n\n\n\n\n\nIn the following graphic we superimpose the data on a map and we can move the slider to see which areas become flooded over time.\n\nflood_output.hvplot.quadmesh(x='longitude', y='latitude', geo=True, widget_location='bottom', rasterize=True, \\\n                            project=True, clim=(0,1), cmap=[\"rgba(0, 0, 1, 0.1)\",\"darkred\"], tiles=True, \\\n                            clabel=\"        non-flood                                        flood\")",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Dask Client</span>"
    ]
  }
]